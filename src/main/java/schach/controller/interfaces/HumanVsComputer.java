package schach.controller.interfaces;

import schach.controller.ai.AiInterface;
import schach.controller.ai.MinMaxAi;
import schach.model.Board;
import schach.model.Pawn;
import schach.model.Piece;

import java.util.Scanner;

/**
 * Handles the interaction between the human and the computer in Human vs Ai game
 */
public class HumanVsComputer {

    /**
     * the board the game is played on
     */
    private Board board;

    /**
     * the playerInput interface that handles all player input
     */
    private PlayerInput playerInput;

    /**
     * the ai interface that generates new moves by the ai
     */
    private AiInterface aiInterface;

    /**
     * boolean that defines if the play chose color white(true) or black(false)
     */
    private boolean playerIsWhite;

    /**
     * boolean that defines whose turn is next
     */
    private boolean playersTurn;

    /**
     * Constructor initializing the fields and setting up a board with the starting lineup
     */
    private void init(){
        this.board = new Board();
        board.initLineUp();

        this.playerIsWhite = askForWhite();
        this.playersTurn = true;
        if (!playerIsWhite){
            this.playersTurn = false;
        }

        this.playerInput = new PlayerInput(board, playerIsWhite);
        this.aiInterface = new MinMaxAi(board, !playerIsWhite);

        board.printBoard();
    }

    /**
     * Routine that handles the interaction between player and ai
     * and asking for moves
     */
    public void runningRoutine(){
        init();
        boolean running = true;
        while (running){
            if (playersTurn){
                playerMove();
                playersTurn = false;
            } else {
                computerMove();
                playersTurn = true;
            }
            board.printBoard();
            if (playersTurn && board.getCheck().isCheckMate(!playerIsWhite) || !playersTurn && board.getCheck().isCheckMate(playerIsWhite)){
                running = false;
                System.out.println("CHECKMATE!");
            }
        }
    }

    /**
     * I/O method that asks for the color the player wants
     * @return true if input 'white', false if input 'black'
     */
    private boolean askForWhite(){
        System.out.println("Which color do you want to play with? (white/black)");
        boolean running = true;
        while (running){
            Scanner scanner = new Scanner(System.in);
            String input = scanner.nextLine();
            if (input.equals("white")){
                return true;
            }
            if (input.equals("black")){
                return false;
            }
        }
        return false;
    }

    /**
     * gets the move input by the playerInput interface, processes it so it can get forwarded
     * to the board move call. Checks for validation and if its a promotion, if invalid move:
     * recursively calls it self
     */
    private void playerMove(){
        String playerMove = playerInput.inputRoutine();
        String startDenotation = playerMove.substring(0,2);
        String targetDenotation = playerMove.substring(3,5);
        Piece piece = board.squareByDenotation(startDenotation).getOccupier();

        board.movePiece(startDenotation, targetDenotation);
        if (piece.isValidMove()){
            if (playerInput.isPromotion() && piece instanceof Pawn){
                Pawn p = (Pawn) piece;
                String prom = playerMove.substring(5);
                p.doPromotion(prom);
            }
            return;
        } else {
            System.out.println("!Move not allowed");
            playerMove();
        }

    }

    /**
     * gets the move generated by the ai and process it so it can be forwarded to a board move call
     * checks for promotion
     */
    private void computerMove(){
        System.out.println("Computer generating Move ...");
        String computerMove = aiInterface.getNextMove();
        String startDenotation = computerMove.substring(0,2);
        String targetDenotation = computerMove.substring(3,5);
        board.movePiece(startDenotation, targetDenotation);
    }

}
