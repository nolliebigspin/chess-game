package schach.controller.interfaces;

import schach.controller.ai.Move;
import schach.controller.ai.SimpleAi;
import schach.model.Board;
import schach.model.Piece;
import schach.model.Square;

import java.util.ArrayList;
import java.util.List;

/**
 * Class that act as a interface between ai and the game/input
 * generates and stores all information the ai will need
 */
public class AiInteface {

    /**
     * the board the game is played on
     */
    private Board board;

    /**
     * the actual ai that will generate new moves
     */
    private SimpleAi ai;

    /**
     * color the ai will play with
     */
    private boolean white;

    /**
     * the constructor initializing the ai and fields
     * @param board
     * @param isWhite
     */
    public AiInteface(Board board, boolean isWhite){
        this.board = board;
        this.white = isWhite;
        this.ai = new SimpleAi(this);
    }

    /**
     * gets the next move generated by the ai
     * @return String that represents the next move
     */
    protected String getNextMove(){
        return ai.getNextMove();
    }

    /**
     * gets all active pieces played by the ai
     * @return List of active Pieces played by the ai
     */
    protected List<Piece> getAiPices(){
        return board.allActivePieces(white);
    }

    /**
     * gets all active pieces played by the enemy player
     * @return List of all active pieces played by the ai
     */
    protected List<Piece> getEnemyPieces(){
        return board.allActivePieces(!white);
    }

    /**
     * gets all moves possible for the ai in the current turn
     * @return List of moves currently possible for the ai
     */
    public List<Move> getAiMoves(){
        List<Move> moves = new ArrayList<>();
        List<Piece> aiPieces = getAiPices();
        for (Piece piece: aiPieces){
            piece.updateLegals();
            List<Square> legals = piece.getLegalNextSquares();
            for (Square square: legals){
                moves.add(new Move(piece, square));
            }
        }
        return moves;
    }

    /**
     * gets all moves possible for the player in the current turn
     * @return List of Moves currently possible for the player
     */
    protected List<Move> getEnemyMoves(){
        List<Move> moves = new ArrayList<>();
        List<Piece> enemyPieces = getEnemyPieces();
        for (Piece piece: enemyPieces){
            piece.updateLegals();
            List<Square> legals = piece.getLegalNextSquares();
            for (Square square: legals){
                moves.add(new Move(piece, square));
            }
        }
        return moves;
    }
}
